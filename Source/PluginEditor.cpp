/*
  ==============================================================================

    This file was auto-generated by the Jucer!

    It contains the basic startup code for a Juce application.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"

//==============================================================================
JuceDemoPluginAudioProcessorEditor::JuceDemoPluginAudioProcessorEditor (JuceDemoPluginAudioProcessor* ownerFilter)
    : AudioProcessorEditor (ownerFilter),
      midiKeyboard (ownerFilter->keyboardState, MidiKeyboardComponent::horizontalKeyboard),
      infoLabel (String::empty),
      gainLabel ("", "Throughput level:"),
      delayLabel ("", "Delay:"),
	  sourceLabel("", "Source Selection:"),
      gainSlider ("gain"),
      delaySlider ("delay"),
	  sourceSlider("Source")
{
	// add some sliders..
    addAndMakeVisible (&gainSlider);
    gainSlider.setSliderStyle (Slider::Rotary);
    gainSlider.addListener (this);
    gainSlider.setRange (0.0, 1.0, 0.01);

    addAndMakeVisible (&delaySlider);
    delaySlider.setSliderStyle (Slider::Rotary);
    delaySlider.addListener (this);
    delaySlider.setRange (0.0, 1.0, 0.01);

	addAndMakeVisible(&sourceSlider);
	sourceSlider.setSliderStyle(Slider::LinearVertical);
	sourceSlider.addListener(this);
	sourceSlider.setRange(0.0, 1.0, 0.01);
	sourceSlider.setValue(0);
	sourceSlider.repaint();


    // add some labels for the sliders..
    gainLabel.attachToComponent (&gainSlider, false);
    gainLabel.setFont (Font (11.0f));

    delayLabel.attachToComponent (&delaySlider, false);
    delayLabel.setFont (Font (11.0f));

	sourceLabel.attachToComponent (&sourceSlider, false);
    sourceLabel.setFont (Font (11.0f));

    // add the midi keyboard component..
    addAndMakeVisible (&midiKeyboard);

    // add a label that will display the current timecode and status..
    addAndMakeVisible (&infoLabel);
    infoLabel.setColour (Label::textColourId, Colours::blue);

    // add the triangular resizer component for the bottom-right of the UI
    addAndMakeVisible (resizer = new ResizableCornerComponent (this, &resizeLimits));
    resizeLimits.setSizeLimits (600, 610, 600, 610);

    // set our component's initial size to be the last one that was stored in the filter's settings
    setSize (ownerFilter->lastUIWidth,
             ownerFilter->lastUIHeight);
	waveClicked = -1;
    startTimer (50);
}

void JuceDemoPluginAudioProcessorEditor::mouseDown(const MouseEvent &event) {
	lastDrag = event.getPosition().toFloat();
	waveClicked = checkIfInWavetable((int)lastDrag.getX(), (int)lastDrag.getY());
}

void JuceDemoPluginAudioProcessorEditor::mouseUp(const MouseEvent &) {
	waveClicked = -1;
}

void JuceDemoPluginAudioProcessorEditor::mouseDrag(const MouseEvent &event) {
	if (waveClicked == -1) {
		return;
	}
	auto pos = event.getPosition().toFloat();
	auto dragVec = pos - lastDrag;
	auto dragDistLeft = dragVec;
	int i = 0;
	while (dragDistLeft.getDistanceFromOrigin() > 0.2f && i < 10000) {
		checkIfInWavetable((int)lastDrag.getX(), (int)lastDrag.getY(), waveClicked);
		auto dPos = (dragVec/dragVec.getDistanceFromOrigin())*0.01f;
		dragDistLeft -= dPos;
		lastDrag += dPos;
		i++;
	}
	lastDrag = pos;
	checkIfInWavetable((int)lastDrag.getX(), (int)lastDrag.getY(), waveClicked );
	repaint();
}

int JuceDemoPluginAudioProcessorEditor::checkIfInWavetable(int x, int y, int forceTable) {
	x-=WAVESIZE;
	if (x < WAVESIZE && x >= 0) {
		for (int i = 0; i < 2; i++) {
			if ((y < WAVEHEIGHT*2 && y >= 0 && forceTable == -1 )|| forceTable == i) {
				getProcessor()->wave[x+i*WAVESIZE] = std::max(std::min(((float) -y+WAVEHEIGHT)/WAVEHEIGHT, 1.f), -1.f);
				return i;
			}
			y -= ((int) WAVEHEIGHT * 2.f + TABLESPACING);
		}
		
	}
	return -1;
}

JuceDemoPluginAudioProcessorEditor::~JuceDemoPluginAudioProcessorEditor()
{
}

//==============================================================================
void JuceDemoPluginAudioProcessorEditor::paint (Graphics& g)
{
    g.setGradientFill (ColourGradient (Colours::white, 0, 0, Colours::grey, 0, (float) getHeight(), false));
	g.fillAll();
	g.setColour(Colours::black);
    g.fillRect(300, 0, WAVESIZE, (int) WAVEHEIGHT * 2);
	g.fillRect(300, 310, WAVESIZE, (int) WAVEHEIGHT * 2);
	g.setColour(Colours::white);
	float *wave = getProcessor()->wave;
	for (int i = 0 ; i < WAVESIZE; i++) {
		g.fillRect(300.f+i, WAVEHEIGHT, 1.f, -wave[i]*WAVEHEIGHT);
		g.fillRect(300.f+i, WAVEHEIGHT*3+TABLESPACING, 1.f, -wave[i+WAVESIZE]*WAVEHEIGHT);
	}
    
}

void JuceDemoPluginAudioProcessorEditor::resized()
{
    infoLabel.setBounds (10, 4, 400, 25);
    gainSlider.setBounds (20, 60, 150, 40);
    delaySlider.setBounds (150, 60, 150, 40);
	sourceSlider.setBounds(50, 350, 20, 100);

    const int keyboardHeight = 70;
    midiKeyboard.setBounds (4, getHeight() - keyboardHeight - 4, (getWidth() - 8)/2, keyboardHeight);

    resizer->setBounds (getWidth() - 16, getHeight() - 16, 16, 16);

    getProcessor()->lastUIWidth = getWidth();
    getProcessor()->lastUIHeight = getHeight();
}

//==============================================================================
// This timer periodically checks whether any of the filter's parameters have changed...
void JuceDemoPluginAudioProcessorEditor::timerCallback()
{
    JuceDemoPluginAudioProcessor* ourProcessor = getProcessor();

    AudioPlayHead::CurrentPositionInfo newPos (ourProcessor->lastPosInfo);

    if (lastDisplayedPosition != newPos)
        displayPositionInfo (newPos);
	
    gainSlider.setValue (ourProcessor->gain, dontSendNotification);
    delaySlider.setValue (ourProcessor->delay, dontSendNotification);
}

// This is our Slider::Listener callback, when the user drags a slider.
void JuceDemoPluginAudioProcessorEditor::sliderValueChanged (Slider* slider)
{
    if (slider == &gainSlider)
    {
        // It's vital to use setParameterNotifyingHost to change any parameters that are automatable
        // by the host, rather than just modifying them directly, otherwise the host won't know
        // that they've changed.
        getProcessor()->setParameterNotifyingHost (JuceDemoPluginAudioProcessor::gainParam,
                                                   (float) gainSlider.getValue());
    }
    else if (slider == &delaySlider)
    {
        getProcessor()->setParameterNotifyingHost (JuceDemoPluginAudioProcessor::delayParam,
                                                   (float) delaySlider.getValue());
    }
	else if (slider == &sourceSlider)
	{
		getProcessor()->setParameterNotifyingHost (JuceDemoPluginAudioProcessor::sourceParam,
													(float) sourceSlider.getValue());
	}
}

//==============================================================================
// quick-and-dirty function to format a timecode string
static const String timeToTimecodeString (const double seconds)
{
    const double absSecs = fabs (seconds);

    const int hours =  (int) (absSecs / (60.0 * 60.0));
    const int mins  = ((int) (absSecs / 60.0)) % 60;
    const int secs  = ((int) absSecs) % 60;

    String s (seconds < 0 ? "-" : "");

    s << String (hours).paddedLeft ('0', 2) << ":"
      << String (mins) .paddedLeft ('0', 2) << ":"
      << String (secs) .paddedLeft ('0', 2) << ":"
      << String (roundToInt (absSecs * 1000) % 1000).paddedLeft ('0', 3);

    return s;
}

// quick-and-dirty function to format a bars/beats string
static const String ppqToBarsBeatsString (double ppq, double /*lastBarPPQ*/, int numerator, int denominator)
{
    if (numerator == 0 || denominator == 0)
        return "1|1|0";

    const int ppqPerBar = (numerator * 4 / denominator);
    const double beats  = (fmod (ppq, ppqPerBar) / ppqPerBar) * numerator;

    const int bar    = ((int) ppq) / ppqPerBar + 1;
    const int beat   = ((int) beats) + 1;
    const int ticks  = ((int) (fmod (beats, 1.0) * 960.0 + 0.5));

    String s;
    s << bar << '|' << beat << '|' << ticks;
    return s;
}

// Updates the text in our position label.
void JuceDemoPluginAudioProcessorEditor::displayPositionInfo (const AudioPlayHead::CurrentPositionInfo& pos)
{
    lastDisplayedPosition = pos;
    String displayText;
    displayText.preallocateBytes (128);

    displayText << String (pos.bpm, 2) << " bpm, "
                << pos.timeSigNumerator << '/' << pos.timeSigDenominator
                << "  -  " << timeToTimecodeString (pos.timeInSeconds)
                << "  -  " << ppqToBarsBeatsString (pos.ppqPosition, pos.ppqPositionOfLastBarStart,
				pos.timeSigNumerator, pos.timeSigDenominator);

    if (pos.isRecording)
        displayText << "  (recording)";
    else if (pos.isPlaying)
        displayText << "  (playing)";

    infoLabel.setText (displayText, dontSendNotification);
}
